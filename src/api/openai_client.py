import asyncio
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Iterable

from openai import AsyncOpenAI, OpenAIError

from src.core.config import settings
from src.api.prompts import POST_GENERATION_PROMPT, POSTPROCESS_POST_PROMPT, HASHTAGS_GENERATION_PROMPT
from src.api.tokens_stats import TokensUsage, calculate_cost
from src.api.openai_pricing import get_effective_pricing

logger = logging.getLogger(__name__)


def _write_boot_debug(title: str, body: str) -> None:
    """
    Пишет подробный лог в other/boot_debug.log без усечений (только в DEBUG_MODE).
    """
    if not getattr(settings, "DEBUG_MODE", False):
        return
    try:
        base_dir = Path(__file__).resolve().parents[2]
        log_path = base_dir / "other" / "boot_debug.log"
        log_path.parent.mkdir(parents=True, exist_ok=True)
        # Ограничиваем размер debug-лога, чтобы не разрастался бесконечно.
        # По требованиям проекта: общий размер логов не должен превышать ~100 МБ, старое можно удалять.
        max_bytes = 100 * 1024 * 1024
        try:
            if log_path.exists() and log_path.stat().st_size > max_bytes:
                rotated = log_path.with_suffix(".log.1")
                # Удаляем более старую ротацию (держим максимум 2 файла: текущий и .1)
                if rotated.exists():
                    rotated.unlink(missing_ok=True)
                log_path.rename(rotated)
        except Exception:
            # Если ротация не удалась — лучше продолжить, чем падать
            pass
        with log_path.open("a", encoding="utf-8") as f:
            f.write(f"\n[{datetime.now().isoformat()}] {title}\n")
            f.write(body)
            if not body.endswith("\n"):
                f.write("\n")
            f.write("-" * 80 + "\n")
    except Exception:
        # Не падаем из-за проблем с логом
        pass


class OpenAIClient:
    """
    Клиент для взаимодействия с OpenAI.
    Используется как альтернатива YandexGPT и полностью повторяет формат ответов.
    """

    SYSTEM_PROMPT = (
        "Ты помощник для создания структурированного контента для постов в Telegram. "
        "КРИТИЧЕСКИ ВАЖНО: ВСЁ должно быть переведено на русский язык - названия цветов, бренды, "
        "любой текст. НЕ оставляй китайские иероглифы НИГДЕ (включая бренд/аромат/характеристики). "
        "Если не можешь корректно перевести фрагмент — УДАЛИ его. Всегда отвечай только валидным JSON."
    )

    # Компактный промпт только для OpenAI: специально сделан короче общего POST_GENERATION_PROMPT,
    # чтобы снизить входные токены и ускорить ответы, не теряя ключевых правил.
    OPENAI_COMPACT_PROMPT_V1 = """
Ты создаёшь контент для Telegram-поста по данным товара (JSON).
Требования:
- Пиши ТОЛЬКО на русском. Никаких английских слов и китайских иероглифов.
- Не выдумывай характеристики. Используй только входные данные.
- Без «воды» и продающих формулировок.
- Нельзя указывать конкретный пол/гендер (мужской, женский, для мужчин, для женщин и т.п.), даже если они есть во входных данных. ИСКЛЮЧЕНИЕ: можно указывать "для детей", "детское" и т.п., если это указано в оригинальном описании товара.
- Запрещено добавлять гендерные/возрастные формулировки в любые поля, особенно в "Цвета" и "Размеры". Нельзя: «для мальчиков», «для девочек», «мужской/женский», «унисекс». Если такие фразы встречаются во входе — УДАЛИ их.
- Не упоминай артикулы, SKU, ID, коды.
- additional_info всегда {}.

Верни ТОЛЬКО JSON (без markdown) со структурой:
{
  "title": "до 60 символов, БЕЗ размеров (ни в виде '35 × 24 × 17 см', ни '35x24x17', ни любых других форматов)",
  "description": "2–4 коротких предложения, без банальностей",
  "main_characteristics": { "Название": "значение/список" },
  "additional_info": {},
  "emoji": "один эмодзи"
}

Правило анти-дублирования:
- description = только общая информация (конструкция/особенности/назначение без банальностей).
- main_characteristics = конкретика (состав/материал/цвета/размеры/объём/ключевые параметры).
- Не повторяй одно и то же в description и main_characteristics.

⚠️ КРИТИЧЕСКИ ВАЖНО - ТОЧНЫЕ РАЗМЕРЫ:
- Если в исходном описании указаны ТОЧНЫЕ размеры (конкретные числовые значения, размеры для разных вариантов комплектации и т.п.), то в поле "Размеры" нужно указать эти размеры ТОЧНО, переведя на русский язык и сохранив все числовые значения.
- НЕЛЬЗЯ заменять точные размеры на общие фразы типа "есть варианты стандартного и увеличенного размера", "доступны разные размеры", "размеры в ассортименте", "стандартный и увеличенный размер" и т.п.
- Если указаны конкретные размеры для разных вариантов (стандартный, увеличенный и т.д.), перечисли их ТОЧНО с указанием всех параметров.

Если вход содержит available_colors/available_sizes — используй их.
Если вход содержит sku_props/skus — используй их только чтобы понять варианты (цвет/размер/комплектация), но НЕ перечисляй все варианты в description.
Если вход содержит translated_sku_prices — не придумывай новых названий, опирайся только на них.

Данные товара (JSON):
{product_data}
""".strip()

    # Версия v2: всё ещё компактно, но заметно строже к «галлюцинациям» и «воде».
    # Цель: сохранить низкие входные токены и при этом повысить точность описания.
    OPENAI_COMPACT_PROMPT_V2 = """
Ты создаёшь контент для Telegram-поста по данным товара (JSON).

ЖЁСТКИЕ ПРАВИЛА (важнее всего):
- Пиши ТОЛЬКО на русском. Никаких английских слов и китайских иероглифов.
- НИЧЕГО не выдумывай. Каждая фраза должна опираться на входные данные.
- Убери «воду» и общие слова (модульный/унифицированный/предусматривает/конструкция позволяет и т.п.), если это прямо не подтверждено данными.
- ⚠️ КРИТИЧЕСКИ ВАЖНО: НИКОГДА не используй мета-комментарии о самом описании или источнике данных. Запрещены фразы: "В описании указаны...", "В описании упомянуты...", "производитель указал", "страна производства указана", "в данных указано", "в характеристиках указано", "в информации указано" и любые подобные отсылки к другому описанию или источнику данных. Описывай товар напрямую, как будто ты сам видишь товар, без отсылок к описанию или данным.
- Запрещён канцелярит/казённые формулировки. НЕ используй фразы (или их вариации): «формат исполнения», «представлен вариантами», «данный товар», «имеет место», «осуществляется», «в рамках», «выполнен в формате», «предусматривает», «как по отдельности», «реализуется отдельно».
- Нельзя указывать конкретный пол/гендер (мужской, женский, для мужчин, для женщин и т.п.), даже если они есть во входных данных. ИСКЛЮЧЕНИЕ: можно указывать "для детей", "детское" и т.п., если это указано в оригинальном описании товара.
- Не упоминай артикулы, SKU, ID, коды.
- Не добавляй поля со значениями «прочее/другое/other/其他/не указан/нет данных» — такие поля нужно ПРОПУСТИТЬ.
- КРИТИЧЕСКИ: если материал/состав неопределённый или слишком общий, поле "Состав"/"Материал" НЕЛЬЗЯ добавлять. Запрещены значения и формулировки: «ткань», «материал», «текстиль», «другая ткань», «другие ткани», «прочая ткань», «иная ткань», «другие материалы», «прочие материалы», «смесь материалов», «неизвестно», «не указан(о)».
- Не выводи «Сертификаты» (и любые поля про сертификаты/3C/CQC), если значение не конкретное.
- Не добавляй «Диапазон цен» и «Варианты комплектов» как характеристики: цены и варианты будут оформлены вне JSON в готовом посте.
- Не добавляй «Гарантия»/«Срок службы» и любые гарантийные условия: это не выводим в постах.
- Не добавляй «Источник»/«Платформа»/«Маркетплейс»/«Ссылка»: это не выводим в постах.
- Если переданы price_entries или translated_sku_prices (режим цен advanced) — это уже готовые позиции с ценами. Не придумывай новые, не суммаризируй их и не вставляй цены в description/main_characteristics. Эти цены будут показаны системой отдельно; используй их только как контекст для понимания ассортимента.
- Запрещено использовать фразы «в ассортименте», «в ассортименте: …», «в наличии в ассортименте» и любые вариации. В тексте и характеристиках такие пометки не нужны.
- В description НЕЛЬЗЯ указывать любые измеримые конкретики (цена, объём, размеры, вес, количество элементов/предметов, диапазоны). Это должно быть в main_characteristics или будет добавлено системой ниже.
- В description НЕ пиши цифры, если это не часть официального названия модели/серии (и то по возможности избегай).
- ⚠️ ЗАПРЕЩЕНО добавлять в main_characteristics характеристики: "Назначение", "Способ использования", "Применение", "Использование", "Для чего", "Кому подходит", "Варианты использования", "Условия применения", "Сфера применения" и любые подобные характеристики, описывающие назначение или способ использования товара. Такие характеристики не нужны в описании товара - пользователь сам решает, как использовать товар.
- ⚠️ ЗАПРЕЩЕНО добавлять характеристику "Конструкция", если она описывает способ использования (например, "двухвариантное ношение", "сменная конструкция"). Если "Конструкция" описывает физическое устройство товара (например, "карманная конструкция", "складная конструкция") - лучше описать это в description, а не в характеристиках.
- Не добавляй характеристику «Упаковка», если это обычная товарная упаковка (коробка/пакет/картон). Упаковку указывай только если она реально отличает товар (например: подарочная коробка-матрёшка, футляр, кейс, тканевый мешок с вышивкой).
- Запрещены «рассуждения» и классификации: не пиши фразы вида «относится к категории…», «является сувениром», «подходит для близких/родных/подарка» и т.п., даже если во входных данных есть поля про категории/адресатов.
- Не делай вывод «туристический сувенир»/«сувенирный» без прямого подтверждения в названии товара.
- КРИТИЧЕСКИ ВАЖНО: НИКОГДА не указывай назначение товара, варианты использования и условия применения. Запрещены фразы вида: «подходит для…», «для домашнего использования», «для холодной погоды», «для…», «используется для…», «предназначен для…», «подходит для…», «кому подходит», «как использовать» и т.п. Описывай товар таким, какой он есть (материалы, конструкция, свойства), БЕЗ указания для чего, кому и как его использовать. Пользователь сам решает, как использовать товар.
- Если есть характеристика «Цвета», перечисляй ТОЛЬКО реальные цвета/цветовые сочетания/принты. Игнорируй значения, которые выглядят как название объекта/персонажа/серии (например «корейская кукла»).
- В «Цвета» НЕЛЬЗЯ добавлять тип товара: нельзя «верблюжий пиджак/чёрные брюки». Цвет = только цвет (например «верблюжий», «чёрный»).
- КРИТИЧЕСКИ ВАЖНО: НИКОГДА не включай технические коды типа "f0045", "f0047", "d0004", "d0005" или их комбинации ("d0004+f0045") в названия цветов. Если цвет указан как "белый f0045" - пиши ТОЛЬКО "белый", убирай все коды!
- Если размеры приходят в виде кодов (например u?k4, uk?10) — нормализуй их в «UK4, UK6, …» и если их много — укажи диапазон «UK4-UK12».
- КРИТИЧЕСКИ: в ответе не должно быть китайских иероглифов. Если во входных значениях есть китайский текст — переведи на русский или удали поле целиком.
- Запрещено указывать дату/время изготовления/производства/партию/сроки (например «произведён в ноябре», «дата производства», «2024-11»). Если во входных данных есть такие фрагменты — игнорируй их.
- Запрещено указывать сезоны и времена года (весна, лето, осень, зима, осенний, зимний и т.п.), даже если это указано во входных данных. Не пиши фразы вида «сезонность осень», «для осени», «осенняя коллекция» и т.п.
- Запрещено указывать формат выпуска, заявления производителя, маркетинговые формулировки (например «не сетевой формат», «заявлен как…», «выпуск заявлен как…» и т.п.). Такая информация не относится к описанию товара и не должна упоминаться.

Формат ответа:
Верни ТОЛЬКО JSON (без markdown) со структурой:
{
  "title": "до 60 символов, БЕЗ перечислений (без двоеточий и списков), БЕЗ размеров (ни в виде '35 × 24 × 17 см', ни '35x24x17', ни любых других форматов размеров), БЕЗ артикулов, SKU, ID и кодов товара",
  "description": "2–4 коротких предложения (до 640 символов суммарно), сухо и по делу. Добавь 3–5 КОНКРЕТНЫХ фактов из входных данных. Описывай товар таким, какой он есть (материалы, конструкция, свойства), БЕЗ указания назначения, вариантов использования и условий применения.",
  "main_characteristics": { "Название": "значение/список" },
  "additional_info": {},
  "emoji": "один эмодзи"
}

Правило анти-дублирования:
- description = только общая суть товара без перечисления параметров списком.
- main_characteristics = конкретика (питание/аккумулятор/комплектация/ключевые параметры).
- Не повторяй одно и то же в description и main_characteristics.

Спец-правило для одежды/обуви (если товар — одежда или обувь по названию/свойствам):
- main_characteristics: СТРОГО в следующем порядке:
  - одежда: "Состав", затем "Цвета", затем "Размеры", затем "Уточнения по размерам" (если есть, ТОЛЬКО для SZWEGO!)
  - обувь: "Материал", затем "Цвета", затем "Размеры", затем "Уточнения по размерам" (если есть, ТОЛЬКО для SZWEGO!)
- Никаких других полей (запрещены "Стиль", "Длина", "Назначение", "Способ использования", "Применение", "Использование", "Для чего", "Кому подходит", "Варианты использования", "Условия применения", "Сфера применения" и любые подобные характеристики, описывающие назначение или способ использования товара).
- Если в размерах указан ТОЛЬКО "универсальный/one size/均码/единый размер" — поле "Размеры" НЕ добавляй.
- Если размеры смешанные (например, "универсальный/42-48") — убери "универсальный" и оставь только "42-48".
- КРИТИЧЕСКИ ВАЖНО: Если есть несколько размеров (например, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180), ВСЕГДА указывай диапазон (например, "80-180"). НЕ перечисляй размеры списком через запятую или маркерами. Если размеры идут подряд — всегда используй формат "минимум-максимум".
- ⚠️ КРИТИЧЕСКИ ВАЖНО - ТОЧНЫЕ РАЗМЕРЫ: Если в исходном описании указаны ТОЧНЫЕ размеры (конкретные числовые значения, размеры для разных вариантов комплектации и т.п.), то в поле "Размеры" нужно указать эти размеры ТОЧНО, переведя на русский язык и сохранив все числовые значения. НЕЛЬЗЯ заменять точные размеры на общие фразы типа "есть варианты стандартного и увеличенного размера", "доступны разные размеры", "размеры в ассортименте", "стандартный и увеличенный размер" и т.п. Если указаны конкретные размеры для разных вариантов (стандартный, увеличенный и т.д.), перечисли их ТОЧНО с указанием всех параметров.
- "Уточнения по размерам": список, ТОЛЬКО если:
  * В данных товара поле "_platform" равно "szwego" (строго проверяй это условие!)
  * И в описании есть подробные размеры в сантиметрах (обхват талии, бедра, длина, ширина и т.п.)
  Пример: ["обхват талии 66-69-72-75 (растягивается)", "бедра 94-97-100-103", "длина брюк 99-100-101-102"]
  КРИТИЧЕСКИ ВАЖНО: Если поле "_platform" НЕ равно "szwego" - НЕ добавляй поле "Уточнения по размерам" вообще!
  Если блока "Размеры" нет, но есть подробные размеры - добавь их в "Размеры" вместо "Уточнения по размерам".
- В description НЕ упоминай состав/материал, цвета и размеры (они только в характеристиках).

Правило про цвета:
- Если есть несколько вариантов цвета/принта, положи их в main_characteristics ключом "Цвета" (список).
- Не перечисляй цвета в description.

Правило без мусорных характеристик:
- Никогда не добавляй характеристики со значениями «нет», «не применимо», «отсутствует», «none/n-a». Если данных нет — просто НЕ добавляй ключ.

Правило форматирования значений:
- Значения характеристик после двоеточия начинай со строчной буквы (например: "Жесткость: мягкая", "Способ закрытия: молния").
- Исключения: аббревиатуры размеров (S, M, L, XL) и единицы измерения (30 мл и т.п.) оставляй как есть.

Как извлекать смысл:
- Если есть sku_props/skus: используй их, чтобы понять состав набора (какие инструменты встречаются в вариантах). Можно упомянуть 2–4 основных инструмента (без полного перечисления всех вариантов).
- Не делай вывод «основной продукт = ...», если это выглядит как внутренний атрибут и противоречит вариантам комплекта.
- product_props используй только как факты, но отфильтровывай «мусорные» значения (прочее/其他).

Ограничения по объёму:
- main_characteristics: максимум 4 ключа.
- Для наборов электроинструментов используй ОДНУ характеристику "Инструменты": короткая строка/список из 3–4 слов (без маркеров и длинных списков).
- Убирай любые “служебные” характеристики, которые не помогают понять товар.

Данные товара (JSON):
{product_data}
""".strip()

    # Версия v3: усиленная версия compact_v2 с жёсткими правилами против китайских иероглифов,
    # улучшенной стилистикой и филологией, а также паттернами для стабильного формирования поста.
    OPENAI_COMPACT_PROMPT_V3 = """
Ты создаёшь контент для Telegram-поста по данным товара (JSON).

ЖЁСТКИЕ ПРАВИЛА (важнее всего):
- Пиши ТОЛЬКО на русском. Никаких английских слов и китайских иероглифов.
- НИЧЕГО не выдумывай. Каждая фраза должна опираться на входные данные.
- Убери «воду» и общие слова (модульный/унифицированный/предусматривает/конструкция позволяет и т.п.), если это прямо не подтверждено данными.
- ⚠️ КРИТИЧЕСКИ ВАЖНО: НИКОГДА не используй мета-комментарии о самом описании или источнике данных. Запрещены фразы: "В описании указаны...", "В описании упомянуты...", "производитель указал", "страна производства указана", "в данных указано", "в характеристиках указано", "в информации указано" и любые подобные отсылки к другому описанию или источнику данных. Описывай товар напрямую, как будто ты сам видишь товар, без отсылок к описанию или данным.
- Запрещён канцелярит/казённые формулировки. НЕ используй фразы (или их вариации): «формат исполнения», «представлен вариантами», «данный товар», «имеет место», «осуществляется», «в рамках», «выполнен в формате», «предусматривает», «как по отдельности», «реализуется отдельно».
- Нельзя указывать конкретный пол/гендер (мужской, женский, для мужчин, для женщин и т.п.), даже если они есть во входных данных. ИСКЛЮЧЕНИЕ: можно указывать "для детей", "детское" и т.п., если это указано в оригинальном описании товара.
- Не упоминай артикулы, SKU, ID, коды.
- Не добавляй поля со значениями «прочее/другое/other/其他/не указан/нет данных» — такие поля нужно ПРОПУСТИТЬ.
- КРИТИЧЕСКИ: если материал/состав неопределённый или слишком общий, поле "Состав"/"Материал" НЕЛЬЗЯ добавлять. Запрещены значения и формулировки: «ткань», «материал», «текстиль», «другая ткань», «другие ткани», «прочая ткань», «иная ткань», «другие материалы», «прочие материалы», «смесь материалов», «неизвестно», «не указан(о)».
- Не выводи «Сертификаты» (и любые поля про сертификаты/3C/CQC), если значение не конкретное.
- Не добавляй «Диапазон цен» и «Варианты комплектов» как характеристики: цены и варианты будут оформлены вне JSON в готовом посте.
- Не добавляй «Гарантия»/«Срок службы» и любые гарантийные условия: это не выводим в постах.
- Не добавляй «Источник»/«Платформа»/«Маркетплейс»/«Ссылка»: это не выводим в постах.
- Если переданы price_entries или translated_sku_prices (режим цен advanced) — это уже готовые позиции с ценами. Не придумывай новые, не суммаризируй их и не вставляй цены в description/main_characteristics. Эти цены будут показаны системой отдельно; используй их только как контекст для понимания ассортимента.
- Запрещено использовать фразы «в ассортименте», «в ассортименте: …», «в наличии в ассортименте» и любые вариации. В тексте и характеристиках такие пометки не нужны.
- В description НЕЛЬЗЯ указывать любые измеримые конкретики (цена, объём, размеры, вес, количество элементов/предметов, диапазоны). Это должно быть в main_characteristics или будет добавлено системой ниже.
- В description НЕ пиши цифры, если это не часть официального названия модели/серии (и то по возможности избегай).
- ⚠️ ЗАПРЕЩЕНО добавлять в main_characteristics характеристики: "Назначение", "Способ использования", "Применение", "Использование", "Для чего", "Кому подходит", "Варианты использования", "Условия применения", "Сфера применения" и любые подобные характеристики, описывающие назначение или способ использования товара. Такие характеристики не нужны в описании товара - пользователь сам решает, как использовать товар.
- ⚠️ ЗАПРЕЩЕНО добавлять характеристику "Конструкция", если она описывает способ использования (например, "двухвариантное ношение", "сменная конструкция"). Если "Конструкция" описывает физическое устройство товара (например, "карманная конструкция", "складная конструкция") - лучше описать это в description, а не в характеристиках.
- Не добавляй характеристику «Упаковка», если это обычная товарная упаковка (коробка/пакет/картон). Упаковку указывай только если она реально отличает товар (например: подарочная коробка-матрёшка, футляр, кейс, тканевый мешок с вышивкой).
- Запрещены «рассуждения» и классификации: не пиши фразы вида «относится к категории…», «является сувениром», «подходит для близких/родных/подарка» и т.п., даже если во входных данных есть поля про категории/адресатов.
- Не делай вывод «туристический сувенир»/«сувенирный» без прямого подтверждения в названии товара.
- КРИТИЧЕСКИ ВАЖНО: НИКОГДА не указывай назначение товара, варианты использования и условия применения. Запрещены фразы вида: «подходит для…», «для домашнего использования», «для холодной погоды», «для…», «используется для…», «предназначен для…», «подходит для…», «кому подходит», «как использовать» и т.п. Описывай товар таким, какой он есть (материалы, конструкция, свойства), БЕЗ указания для чего, кому и как его использовать. Пользователь сам решает, как использовать товар.
- Если есть характеристика «Цвета», перечисляй ТОЛЬКО реальные цвета/цветовые сочетания/принты. Игнорируй значения, которые выглядят как название объекта/персонажа/серии (например «корейская кукла»).
- В «Цвета» НЕЛЬЗЯ добавлять тип товара: нельзя «верблюжий пиджак/чёрные брюки». Цвет = только цвет (например «верблюжий», «чёрный»).
- КРИТИЧЕСКИ ВАЖНО: НИКОГДА не включай технические коды типа "f0045", "f0047", "d0004", "d0005" или их комбинации ("d0004+f0045") в названия цветов. Если цвет указан как "белый f0045" - пиши ТОЛЬКО "белый", убирай все коды!
- Если размеры приходят в виде кодов (например u?k4, uk?10) — нормализуй их в «UK4, UK6, …» и если их много — укажи диапазон «UK4-UK12».
- КРИТИЧЕСКИ: в ответе не должно быть китайских иероглифов. Если во входных значениях есть китайский текст — переведи на русский или удали поле целиком.
- Запрещено указывать дату/время изготовления/производства/партию/сроки (например «произведён в ноябре», «дата производства», «2024-11»). Если во входных данных есть такие фрагменты — игнорируй их.
- Запрещено указывать сезоны и времена года (весна, лето, осень, зима, осенний, зимний и т.п.), даже если это указано во входных данных. Не пиши фразы вида «сезонность осень», «для осени», «осенняя коллекция» и т.п.
- Запрещено указывать формат выпуска, заявления производителя, маркетинговые формулировки (например «не сетевой формат», «заявлен как…», «выпуск заявлен как…» и т.п.). Такая информация не относится к описанию товара и не должна упоминаться.
- ⚠️ КРИТИЧЕСКИ ВАЖНО: НИКОГДА не добавляй размеры в поле "title" (ни в виде "35 × 24 × 17 см", ни "35x24x17", ни "35-24-17", ни любые другие форматы размеров). Размеры должны быть ТОЛЬКО в поле "Размеры" в main_characteristics, НЕ в title! Если в исходных данных размеры указаны в названии - УБЕРИ их из title.

⚠️⚠️⚠️ КРИТИЧЕСКИ ВАЖНО: БОРЬБА С КИТАЙСКИМИ ИЕРОГЛИФАМИ ⚠️⚠️⚠️
- ВСЕ китайские иероглифы (включая упрощённые и традиционные) ДОЛЖНЫ быть переведены на русский язык.
- Если встречаешь китайские иероглифы в цветах (например: 孔雀绿, 黑色, 白色, 红色) — ОБЯЗАТЕЛЬНО переведи их:
  * 孔雀绿 → "павлиний зелёный" или "изумрудный"
  * 黑色 → "чёрный"
  * 白色 → "белый"
  * 红色 → "красный"
  * 蓝色 → "синий"
  * 绿色 → "зелёный"
  * 黄色 → "жёлтый"
  * 灰色 → "серый"
  * 紫色 → "фиолетовый"
  * 粉色 → "розовый"
  * 棕色 → "коричневый"
  * 橙色 → "оранжевый"
- Если встречаешь китайские иероглифы в названиях/описаниях — переведи их на русский или удали поле целиком, если перевод невозможен.
- Если встречаешь китайские иероглифы в характеристиках — переведи значение на русский или удали характеристику.
- НИКОГДА не оставляй китайские иероглифы в финальном ответе. Это критическая ошибка!
- Примеры НЕПРАВИЛЬНОГО ответа:
  * "Цвета": ["孔雀绿", "синий"] ❌
  * "description": "Комплект включает длинный кардиган 长袖" ❌
- Примеры ПРАВИЛЬНОГО ответа:
  * "Цвета": ["павлиний зелёный", "синий"] ✅
  * "description": "Комплект включает длинный кардиган с длинными рукавами" ✅

⚠️⚠️⚠️ КРИТИЧЕСКИ ВАЖНО: СТИЛИСТИКА И ФИЛОЛОГИЯ ⚠️⚠️⚠️
- Правильное использование числительных и согласование:
  * НЕПРАВИЛЬНО: "Три труса", "Два носка", "Пять перчаток" ❌
  * ПРАВИЛЬНО: "Набор из трёх трусов", "Две пары носков", "Пять пар перчаток", "Комплект из трёх предметов" ✅
  * Для парных предметов (носки, перчатки, варежки) ВСЕГДА используй "пара/пары"
  * Для наборов/комплектов используй "набор из N предметов" или "комплект из N элементов"
- Правильное согласование по роду, числу и падежу:
  * НЕПРАВИЛЬНО: "Кардиган выполнен из полиэстер", "Трусы изготовлены из хлопок" ❌
  * ПРАВИЛЬНО: "Кардиган выполнен из полиэстера", "Трусы изготовлены из хлопка" ✅
  * НЕПРАВИЛЬНО: "Размеры: 18.12, см", "Размеры: 21, 13, см", "Размеры: примерно, 17, см, 26, см" ❌
  * ПРАВИЛЬНО: "Размеры: 18 × 12 см", "Размеры: 21 × 13 см", "Размеры: примерно 17 × 26 см" ✅
- Форматирование размеров:
  * Если размеры указаны как два числа через запятую (например "18, 12" или "18.12") — форматируй как "18 × 12 см"
  * Если размеры указаны как три числа (например "21, 13, 5") — форматируй как "21 × 13 × 5 см"
  * Убирай лишние запятые и пробелы вокруг единиц измерения
  * Используй символ "×" (не "x" и не "X") для обозначения размеров
- Правильное использование предлогов и падежей:
  * НЕПРАВИЛЬНО: "Изготовлен из хлопок", "Выполнен из полиэстер" ❌
  * ПРАВИЛЬНО: "Изготовлен из хлопка", "Выполнен из полиэстера" ✅
- Избегай тавтологий и повторов:
  * НЕПРАВИЛЬНО: "Трусы трусы", "Кардиган кардиган" ❌
  * ПРАВИЛЬНО: "Трусы", "Кардиган" ✅

Формат ответа:
Верни ТОЛЬКО JSON (без markdown) со структурой:
{
  "title": "до 60 символов, БЕЗ перечислений (без двоеточий и списков), БЕЗ размеров (ни в виде '35 × 24 × 17 см', ни '35x24x17', ни любых других форматов размеров), БЕЗ артикулов, SKU, ID и кодов товара",
  "description": "2–4 коротких предложения (до 640 символов суммарно), сухо и по делу. Добавь 3–5 КОНКРЕТНЫХ фактов из входных данных. Описывай товар таким, какой он есть (материалы, конструкция, свойства), БЕЗ указания назначения, вариантов использования и условий применения. ВСЁ на русском языке, БЕЗ китайских иероглифов и английских слов.",
  "main_characteristics": { "Название": "значение/список" },
  "additional_info": {},
  "emoji": "один эмодзи"
}

Правило анти-дублирования:
- description = только общая суть товара без перечисления параметров списком.
- main_characteristics = конкретика (питание/аккумулятор/комплектация/ключевые параметры).
- Не повторяй одно и то же в description и main_characteristics.

Спец-правило для одежды/обуви (если товар — одежда или обувь по названию/свойствам):
- main_characteristics: СТРОГО в следующем порядке:
  - одежда: "Состав", затем "Цвета", затем "Размеры", затем "Уточнения по размерам" (если есть, ТОЛЬКО для SZWEGO!)
  - обувь: "Материал", затем "Цвета", затем "Размеры", затем "Уточнения по размерам" (если есть, ТОЛЬКО для SZWEGO!)
- Никаких других полей (запрещены "Стиль", "Длина", "Назначение", "Способ использования", "Применение", "Использование", "Для чего", "Кому подходит", "Варианты использования", "Условия применения", "Сфера применения" и любые подобные характеристики, описывающие назначение или способ использования товара).
- Если в размерах указан ТОЛЬКО "универсальный/one size/均码/единый размер" — поле "Размеры" НЕ добавляй.
- Если размеры смешанные (например, "универсальный/42-48") — убери "универсальный" и оставь только "42-48".
- КРИТИЧЕСКИ ВАЖНО: Если есть несколько размеров (например, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180), ВСЕГДА указывай диапазон (например, "80-180"). НЕ перечисляй размеры списком через запятую или маркерами. Если размеры идут подряд — всегда используй формат "минимум-максимум".
- ⚠️ КРИТИЧЕСКИ ВАЖНО - ТОЧНЫЕ РАЗМЕРЫ: Если в исходном описании указаны ТОЧНЫЕ размеры (конкретные числовые значения, размеры для разных вариантов комплектации и т.п.), то в поле "Размеры" нужно указать эти размеры ТОЧНО, переведя на русский язык и сохранив все числовые значения. НЕЛЬЗЯ заменять точные размеры на общие фразы типа "есть варианты стандартного и увеличенного размера", "доступны разные размеры", "размеры в ассортименте", "стандартный и увеличенный размер" и т.п. Если указаны конкретные размеры для разных вариантов (стандартный, увеличенный и т.д.), перечисли их ТОЧНО с указанием всех параметров.
- "Уточнения по размерам": список, ТОЛЬКО если:
  * В данных товара поле "_platform" равно "szwego" (строго проверяй это условие!)
  * И в описании есть подробные размеры в сантиметрах (обхват талии, бедра, длина, ширина и т.п.)
  Пример: ["обхват талии 66-69-72-75 (растягивается)", "бедра 94-97-100-103", "длина брюк 99-100-101-102"]
  КРИТИЧЕСКИ ВАЖНО: Если поле "_platform" НЕ равно "szwego" - НЕ добавляй поле "Уточнения по размерам" вообще!
  Если блока "Размеры" нет, но есть подробные размеры - добавь их в "Размеры" вместо "Уточнения по размерам".
- В description НЕ упоминай состав/материал, цвета и размеры (они только в характеристиках).

Правило про цвета:
- Если есть несколько вариантов цвета/принта, положи их в main_characteristics ключом "Цвета" (список).
- Не перечисляй цвета в description.
- ВСЕГДА переводи китайские названия цветов на русский (см. таблицу переводов выше).
- Если цвет указан на английском — переведи на русский (Black → "чёрный", White → "белый").
- Цвета пиши с маленькой буквы: ["чёрный", "белый", "павлиний зелёный"].

Правило без мусорных характеристик:
- Никогда не добавляй характеристики со значениями «нет», «не применимо», «отсутствует», «none/n-a». Если данных нет — просто НЕ добавляй ключ.

Правило форматирования значений:
- Значения характеристик после двоеточия начинай со строчной буквы (например: "Жесткость: мягкая", "Способ закрытия: молния").
- Исключения: аббревиатуры размеров (S, M, L, XL) и единицы измерения (30 мл и т.п.) оставляй как есть.
- Размеры в формате "число × число см" (используй символ "×", не "x" и не "X").

Как извлекать смысл:
- Если есть sku_props/skus: используй их, чтобы понять состав набора (какие инструменты встречаются в вариантах). Можно упомянуть 2–4 основных инструмента (без полного перечисления всех вариантов).
- Не делай вывод «основной продукт = ...», если это выглядит как внутренний атрибут и противоречит вариантам комплекта.
- product_props используй только как факты, но отфильтровывай «мусорные» значения (прочее/其他).

Ограничения по объёму:
- main_characteristics: максимум 4 ключа.
- Для наборов электроинструментов используй ОДНУ характеристику "Инструменты": короткая строка/список из 3–4 слов (без маркеров и длинных списков).
- Убирай любые "служебные" характеристики, которые не помогают понять товар.

ПРИМЕРЫ ПРАВИЛЬНОГО ФОРМИРОВАНИЯ:

Пример 1 (одежда с китайскими цветами):
Входные данные: {"title": "长袖T恤", "available_colors": ["黑色", "白色", "红色"]}
ПРАВИЛЬНЫЙ ответ:
{
  "title": "Футболка с длинными рукавами",
  "description": "Футболка с длинными рукавами. Изготовлена из хлопка.",
  "main_characteristics": {
    "Состав": "хлопок",
    "Цвета": ["чёрный", "белый", "красный"]
  },
  "additional_info": {},
  "emoji": "👕"
}

Пример 2 (набор трусов с правильным числительным):
Входные данные: {"title": "3条内裤套装", "product_props": [{"材质": "modal"}]}
ПРАВИЛЬНЫЙ ответ:
{
  "title": "Набор из трёх трусов",
  "description": "Набор из трёх трусов из модала. Мягкая приятная поверхность.",
  "main_characteristics": {
    "Состав": "модал"
  },
  "additional_info": {},
  "emoji": "🩲"
}

Пример 3 (сумка с правильным форматом размеров):
Входные данные: {"title": "Gucci手机包", "product_props": [{"尺寸": "18.12cm"}]}
ПРАВИЛЬНЫЙ ответ:
{
  "title": "Сумка для телефона Gucci",
  "description": "Компактная сумка для телефона из коллекции Gucci.",
  "main_characteristics": {
    "Размеры": "18 × 12 см"
  },
  "additional_info": {},
  "emoji": "👜"
}

Данные товара (JSON):
{product_data}
""".strip()

    # Константы для Responses API
    # Responses API используется для всех моделей OpenAI (gpt-4 и gpt-5) согласно документации
    GPT5_PREFIXES = ("gpt-5", "o3", "o4")  # Модели, поддерживающие reasoning
    RESPONSES_JSON_TOKENS = 4500  # Лимит токенов для JSON-ответов
    RESPONSES_TRANSLATE_TOKENS = 500  # Лимит токенов для переводов
    RESPONSES_POSTPROCESS_TOKENS = 2000  # Лимит токенов для постобработки текста поста

    def __init__(self, model_name: str | None = None):
        if not settings.OPENAI_API_KEY:
            raise ValueError(
                "OPENAI_API_KEY не задан. Укажите ключ в .env, чтобы использовать OpenAI."
            )

        source_model = model_name or settings.OPENAI_MODEL or "gpt-4o-mini"
        model_raw = source_model.strip()
        self.model = model_raw or "gpt-4o-mini"
        # Responses API используется для всех моделей OpenAI согласно документации
        # Если отключён, используется устаревший Chat Completions API
        self.use_responses_api = getattr(settings, "OPENAI_USE_RESPONSES_API", True)
        
        # Уровень рассуждений для gpt-5 моделей
        # Автоматически определяется поддерживаемые значения для конкретной модели
        reasoning_effort_raw = (getattr(settings, "OPENAI_REASONING_EFFORT", "") or "").strip()
        if reasoning_effort_raw:
            # Нормализуем значение для конкретной модели
            self.reasoning_effort = self._normalize_reasoning_effort(self.model, reasoning_effort_raw)
        else:
            # Используем значение по умолчанию для модели
            _, default_value = self._get_supported_reasoning_effort_values(self.model)
            self.reasoning_effort = default_value

        # ВАЖНО: модели семейства gpt-5 требуют Responses API.
        # Если Responses API отключён, делаем безопасный fallback на совместимую модель
        # для Chat Completions, чтобы избежать «пустых» ответов (content=None).
        if self._is_gpt5_model(self.model) and not self.use_responses_api:
            fallback = (getattr(settings, "OPENAI_FALLBACK_CHAT_MODEL", "") or "gpt-4o-mini").strip() or "gpt-4o-mini"
            logger.warning(
                "Выбрана модель OpenAI '%s' (семейство gpt-5), но Responses API отключён. "
                "Переключаемся на fallback-модель для Chat Completions: '%s'.",
                self.model,
                fallback,
            )
            self.model = fallback

        # Поддержка внешнего шлюза (OpenAI Gateway)
        base_url = (getattr(settings, "OPENAI_BASE_URL", "") or "").strip() or None
        extra_headers: dict[str, str] = {}
        gateway_token = (getattr(settings, "OPENAI_GATEWAY_TOKEN", "") or "").strip()
        if gateway_token:
            extra_headers["X-Gateway-Token"] = gateway_token

        self.client = AsyncOpenAI(
            api_key=settings.OPENAI_API_KEY,
            base_url=base_url,
            default_headers=extra_headers or None,
        )

    @classmethod
    def _is_gpt5_model(cls, model_name: str) -> bool:
        """
        Проверяет, является ли модель семейства gpt-5 (поддерживает reasoning).
        """
        normalized = (model_name or "").strip().lower()
        return any(normalized.startswith(prefix) for prefix in cls.GPT5_PREFIXES)
    
    @classmethod
    def _get_supported_reasoning_effort_values(cls, model_name: str) -> tuple[list[str], str]:
        """
        Возвращает поддерживаемые значения reasoning.effort для конкретной модели и значение по умолчанию.
        
        Согласно документации OpenAI:
        - gpt-5, gpt-5-mini, gpt-5-nano: minimal, low, medium, high (по умолчанию: minimal)
        - gpt-5.1, gpt-5.1-mini, gpt-5.1-nano: none, low, medium, high (по умолчанию: low)
        - gpt-5.2 и другие новые версии: могут иметь свои значения
        
        Returns:
            tuple[list[str], str]: (список поддерживаемых значений, значение по умолчанию)
        """
        normalized = (model_name or "").strip().lower()
        
        # Модели gpt-5.1 и выше используют none вместо minimal
        if normalized.startswith("gpt-5.1") or normalized.startswith("gpt-5.2"):
            return (["none", "low", "medium", "high"], "low")
        
        # Модели gpt-5 (без версии) используют minimal
        if normalized.startswith("gpt-5"):
            return (["minimal", "low", "medium", "high"], "minimal")
        
        # Для остальных gpt-5 моделей (o3, o4 и т.д.) используем значения для gpt-5.1
        if normalized.startswith("o3") or normalized.startswith("o4"):
            return (["none", "low", "medium", "high"], "low")
        
        # По умолчанию (не должно использоваться для не-gpt5 моделей)
        return (["low", "medium", "high"], "low")
    
    def _normalize_reasoning_effort(self, model_name: str, user_value: str) -> str:
        """
        Нормализует значение reasoning.effort для конкретной модели.
        Автоматически конвертирует значения между разными версиями моделей.
        
        Args:
            model_name: Название модели
            user_value: Значение из настроек пользователя
        
        Returns:
            str: Нормализованное значение, поддерживаемое моделью
        """
        supported_values, default_value = self._get_supported_reasoning_effort_values(model_name)
        user_value_lower = (user_value or "").strip().lower()
        
        # Если значение уже поддерживается, возвращаем его
        if user_value_lower in supported_values:
            return user_value_lower
        
        # Автоматическая конвертация между версиями
        conversion_map = {
            "minimal": "low",  # minimal -> low для моделей 5.1+
            "none": "minimal",  # none -> minimal для моделей 5.0
            "low": "low",      # low поддерживается везде
            "medium": "medium",  # medium поддерживается везде
            "high": "high",    # high поддерживается везде
        }
        
        # Пытаемся конвертировать
        if user_value_lower in conversion_map:
            converted = conversion_map[user_value_lower]
            if converted in supported_values:
                logger.info(
                    "Конвертировано значение reasoning.effort: '%s' -> '%s' для модели '%s'",
                    user_value_lower,
                    converted,
                    model_name,
                )
                return converted
        
        # Если конвертация не удалась, используем значение по умолчанию
        logger.warning(
            "Значение reasoning.effort '%s' не поддерживается моделью '%s'. "
            "Поддерживаемые значения: %s. Используется значение по умолчанию: '%s'.",
            user_value_lower,
            model_name,
            supported_values,
            default_value,
        )
        return default_value

    async def generate_post_content(
        self, product_data: dict
    ) -> dict | tuple[dict, TokensUsage]:
        """
        Генерация описания товара через OpenAI.
        
        Returns:
            dict: JSON с содержимым поста
            tuple[dict, TokensUsage]: JSON с содержимым и статистика токенов (если используется новая сигнатура)
        """
        # Важно: используем компактный JSON, чтобы не тратить токены на пробелы/переносы строк
        product_info_str = json.dumps(product_data, ensure_ascii=False, separators=(",", ":"))
        
        # Логирование для анализа количества токенов (только в DEBUG режиме)
        if settings.DEBUG_MODE:
            try:
                import tiktoken
                encoding = tiktoken.encoding_for_model(self.model if self.model.startswith("gpt-") else "gpt-4o")
                prompt_tokens = len(encoding.encode(prompt))
                data_tokens = len(encoding.encode(product_info_str))
                logger.info(
                    f"[OpenAI] Размер промпта: ~{prompt_tokens} токенов, размер данных: ~{data_tokens} токенов, "
                    f"размер JSON данных: {len(product_info_str)} символов"
                )
            except ImportError:
                # Если tiktoken не установлен, просто пропускаем логирование
                pass
            except Exception:
                # Другие ошибки тоже игнорируем, чтобы не ломать основной функционал
                pass

        # Вариант промпта выбирается ТОЛЬКО для OpenAI через .env,
        # чтобы можно было безопасно сравнивать качество/стоимость и быстро откатываться.
        prompt_variant = (getattr(settings, "OPENAI_PROMPT_VARIANT", "") or "compact_v2").strip().lower()
        if prompt_variant in {"shared", "legacy", "default"}:
            prompt = POST_GENERATION_PROMPT.replace("{product_data}", product_info_str)
        elif prompt_variant in {"compact_v1", "v1"}:
            prompt = self.OPENAI_COMPACT_PROMPT_V1.replace("{product_data}", product_info_str)
        elif prompt_variant in {"compact_v3", "v3"}:
            # Улучшенная версия compact_v2 с жёсткими правилами против китайских иероглифов и улучшенной стилистикой
            prompt = self.OPENAI_COMPACT_PROMPT_V3.replace("{product_data}", product_info_str)
        else:
            # По умолчанию используем более строгий compact_v2
            prompt = self.OPENAI_COMPACT_PROMPT_V2.replace("{product_data}", product_info_str)

        if settings.DEBUG_MODE:
            print(f"[OpenAI] Отправляем промпт ({self.model}):\n{prompt[:500]}...")

        def _strip_fences(text: str) -> str:
            cleaned = (text or "").strip()
            if cleaned.startswith("```json"):
                cleaned = cleaned[7:]
            if cleaned.startswith("```"):
                cleaned = cleaned[3:]
            if cleaned.endswith("```"):
                cleaned = cleaned[:-3]
            return cleaned.strip()

        def _extract_first_json_object(text: str) -> str | None:
            """
            Пытается извлечь первый валидный JSON-объект из текста по балансу фигурных скобок.
            Это страховка на случай, если модель вернула лишний текст или оборвала хвост.
            """
            s = (text or "")
            start = s.find("{")
            if start < 0:
                return None
            depth = 0
            in_str = False
            escape = False
            for i in range(start, len(s)):
                ch = s[i]
                if in_str:
                    if escape:
                        escape = False
                        continue
                    if ch == "\\":
                        escape = True
                        continue
                    if ch == '"':
                        in_str = False
                    continue
                else:
                    if ch == '"':
                        in_str = True
                        continue
                    if ch == "{":
                        depth += 1
                    elif ch == "}":
                        depth -= 1
                        if depth == 0:
                            return s[start : i + 1]
            return None

        # Ретраим, если модель обрезала JSON (часто случается при max_output_tokens близко к лимиту)
        max_out = int(getattr(settings, "OPENAI_MAX_OUTPUT_TOKENS", 2400) or 2400)
        max_cap = 6000
        last_exc: Exception | None = None
        last_response_text: str = ""
        last_tokens_usage = TokensUsage()

        for attempt in range(3):
            try:
                result = await self.generate_json_response(
                    system_prompt=self.SYSTEM_PROMPT,
                    user_prompt=prompt,
                    max_output_tokens=max_out,
                    temperature=0.1,  # Низкая температура для детерминированных ответов
                )
                if isinstance(result, tuple):
                    llm_response, tokens_usage = result
                else:
                    llm_response = result
                    tokens_usage = TokensUsage()

                last_response_text = llm_response or ""
                last_tokens_usage = tokens_usage

                if settings.DEBUG_MODE:
                    print(f"[OpenAI] Получен ответ:\n{llm_response}")
                    if tokens_usage.total_tokens > 0:
                        print(
                            f"[OpenAI] Использовано токенов: {tokens_usage.prompt_tokens} входных, "
                            f"{tokens_usage.completion_tokens} выходных, стоимость: ${tokens_usage.total_cost:.6f}"
                        )

                cleaned_response = _strip_fences(llm_response)
                try:
                    parsed_content = json.loads(cleaned_response)
                    return parsed_content, tokens_usage
                except json.JSONDecodeError as exc:
                    # 1) Пробуем вытащить первый JSON-объект (если есть мусор/лишний текст)
                    extracted = _extract_first_json_object(cleaned_response)
                    if extracted:
                        try:
                            parsed_content = json.loads(extracted)
                            return parsed_content, tokens_usage
                        except Exception:
                            pass

                    last_exc = exc
                    # 2) Если похоже на обрезку по лимиту — увеличим max_out и повторим
                    if max_out < max_cap:
                        # Делаем мягкое увеличение: x1.4 + 400
                        max_out = min(max_cap, int(max_out * 1.4) + 400)
                        continue
                    break
            except OpenAIError as exc:
                raise RuntimeError(f"OpenAI вернул ошибку: {exc}") from exc
            except Exception as exc:
                last_exc = exc
                break

        # Если дошли сюда — не смогли получить валидный JSON
        sample = _strip_fences(last_response_text)[:1500]
        raise ValueError(f"OpenAI вернул невалидный JSON: {last_exc}. Response sample:\n{sample}") from last_exc

    async def postprocess_post_text(
        self,
        post_text: str,
    ) -> tuple[str, TokensUsage]:
        """
        Постобработка уже ГОТОВОГО текста поста.

        Задачи:
        - Исправить грамматические, орфографические и стилистические ошибки.
        - Нормализовать числительные, падежи и конструкции с размерами.
        - Перевести оставшиеся иноязычные фрагменты (китайский/английский), кроме брендов.
        - Сохранить структуру блоков поста, разметку, порядок строк и эмодзи.

        ВАЖНО:
        - НЕЛЬЗЯ перепридумывать текст с нуля, только корректировка.
        - НЕЛЬЗЯ добавлять/удалять смысловые блоки.
        """
        if not post_text:
            # Если текста нет — просто возвращаем пустой результат и нулевую статистику
            return post_text, TokensUsage()

        # Формируем промпт для постобработки.
        user_prompt = POSTPROCESS_POST_PROMPT.replace("{post_text}", post_text)

        # Для постобработки используем Responses API (если включено) в текстовом режиме,
        # без навязанного JSON-формата.
        max_out = self.RESPONSES_POSTPROCESS_TOKENS
        system_prompt = (
            "Ты профессиональный редактор и корректор русского языка. "
            "Тебе передают уже готовый пост для Telegram; твоя задача — "
            "аккуратно исправить язык (грамматику, стилистику, числительные, "
            "непереведённые слова), НЕ нарушая структуру блоков и разметку."
        )

        # Логирование промпта постобработки в DEBUG-режиме
        if settings.DEBUG_MODE:
            try:
                logger.debug(
                    "[OpenAI][postprocess] model=%s | prompt_len=%s | system_prompt_len=%s\n"
                    "--- system_prompt ---\n%s\n--- user_prompt ---\n%s\n",
                    self.model,
                    len(user_prompt),
                    len(system_prompt),
                    system_prompt,
                    user_prompt[:2000] if len(user_prompt) > 2000 else user_prompt,
                )
                print(f"[OpenAI][postprocess] Отправляем промпт постобработки ({self.model}):\n{user_prompt[:500]}...")
            except Exception:
                pass

        # Статистика токенов для постобработки считаем отдельно, чтобы можно было
        # чисто анализировать вклад этого шага.
        if self.use_responses_api:
            text, tokens_usage = await self._call_responses_api(
                prompt=user_prompt,
                system_prompt=system_prompt,
                max_output_tokens=max_out,
                temperature=0.1,
                expect_json=False,
            )
        else:
            # Fallback на Chat Completions API (устаревший, но возможный)
            result = await self._call_chat_completions(
                user_prompt,
                system_prompt=system_prompt,
                expect_json=False,
                max_tokens=max_out,
                temperature=0.1,
            )
            if isinstance(result, tuple):
                text, tokens_usage = result
            else:
                text = result
                tokens_usage = TokensUsage()

        cleaned = (text or "").strip()
        # На всякий случай убираем обрамление в ``` если модель всё-таки вернула markdown.
        if cleaned.startswith("```"):
            # Очень грубая очистка: убираем первые и последние тройные кавычки.
            if cleaned.startswith("```json"):
                cleaned = cleaned[7:]
            else:
                cleaned = cleaned[3:]
            if cleaned.endswith("```"):
                cleaned = cleaned[:-3]
            cleaned = cleaned.strip()

        # Если по какой-то причине постобработчик вернул пустую строку,
        # безопаснее отдать исходный текст, чтобы не ломать пользовательский опыт.
        if not cleaned:
            return post_text, tokens_usage

        return cleaned, tokens_usage

    async def generate_hashtags(
        self,
        post_text: str,
    ) -> tuple[list[str], TokensUsage]:
        """
        Генерирует хэштеги на основе готового текста поста.

        Args:
            post_text: Готовый текст поста для Telegram

        Returns:
            tuple[list[str], TokensUsage]: Список хэштегов и статистика токенов
        """
        if not post_text:
            # Если текста нет — возвращаем пустой список и нулевую статистику
            return [], TokensUsage()

        # Формируем промпт для генерации хэштегов
        user_prompt = HASHTAGS_GENERATION_PROMPT.replace("{post_text}", post_text)

        system_prompt = (
            "Ты опытный маркетолог, специализирующийся на работе с маркетплейсами. "
            "Твоя задача — по тексту поста товара дать один-два хэштега, которые отражают только суть товара. "
            "НИКОГДА не используй материал изготовления в хэштегах (металл, кожа, хлопок, шерсть и т.п.). "
            "Если нет бренда и нет другого ключевого свойства (кроме материала), используй ТОЛЬКО ОДИН хэштег с типом товара."
        )

        # Логирование промпта генерации хэштегов в DEBUG-режиме
        if settings.DEBUG_MODE:
            try:
                logger.debug(
                    "[OpenAI][hashtags] model=%s | prompt_len=%s | system_prompt_len=%s\n"
                    "--- system_prompt ---\n%s\n--- user_prompt ---\n%s\n",
                    self.model,
                    len(user_prompt),
                    len(system_prompt),
                    system_prompt,
                    user_prompt[:2000] if len(user_prompt) > 2000 else user_prompt,
                )
                print(f"[OpenAI][hashtags] Отправляем промпт генерации хэштегов ({self.model}):\n{user_prompt[:500]}...")
            except Exception:
                pass

        # Генерируем хэштеги через Responses API или Chat Completions
        max_out = 200  # Для хэштегов достаточно небольшого лимита
        if self.use_responses_api:
            text, tokens_usage = await self._call_responses_api(
                prompt=user_prompt,
                system_prompt=system_prompt,
                max_output_tokens=max_out,
                temperature=0.1,
                expect_json=True,
            )
        else:
            # Fallback на Chat Completions API
            result = await self._call_chat_completions(
                user_prompt,
                system_prompt=system_prompt,
                expect_json=True,
                max_tokens=max_out,
                temperature=0.1,
            )
            if isinstance(result, tuple):
                text, tokens_usage = result
            else:
                text = result
                tokens_usage = TokensUsage()

        # Парсим JSON-ответ
        try:
            # Очищаем ответ от markdown-обрамления, если оно есть
            cleaned = (text or "").strip()
            if cleaned.startswith("```json"):
                cleaned = cleaned[7:]
            if cleaned.startswith("```"):
                cleaned = cleaned[3:]
            if cleaned.endswith("```"):
                cleaned = cleaned[:-3]
            cleaned = cleaned.strip()
            
            data = json.loads(cleaned)
            hashtags = data.get("hashtags", [])
            
            # Валидация: убеждаемся, что это список строк
            if not isinstance(hashtags, list):
                hashtags = []
            else:
                # Фильтруем и очищаем хэштеги
                hashtags = [
                    str(tag).strip().replace(" ", "").replace("#", "")
                    for tag in hashtags
                    if tag and str(tag).strip()
                ]
            
            if settings.DEBUG_MODE:
                try:
                    print(f"[OpenAI][hashtags] Сгенерированы хэштеги: {hashtags}")
                except Exception:
                    pass
            
            return hashtags, tokens_usage
        except (json.JSONDecodeError, KeyError, AttributeError) as exc:
            if settings.DEBUG_MODE:
                try:
                    print(f"[OpenAI][hashtags] Ошибка парсинга JSON: {exc}\nОтвет: {text}")
                except Exception:
                    pass
            # В случае ошибки возвращаем пустой список, но сохраняем статистику токенов
            return [], tokens_usage

    async def generate_json_response(
        self,
        system_prompt: str,
        user_prompt: str,
        max_output_tokens: int | None = None,
        temperature: float | None = None,
    ) -> str | tuple[str, TokensUsage]:
        """
        Универсальный метод получения структурированного ответа (JSON) от модели.
        Использует Responses API для всех моделей согласно документации OpenAI.
        
        Returns:
            str: Текст ответа (старая сигнатура для обратной совместимости)
            tuple[str, TokensUsage]: Текст ответа и статистика токенов (новая сигнатура)
        """
        # Responses API используется для всех моделей согласно документации
        if self.use_responses_api:
            text, tokens_usage = await self._call_responses_api(
                prompt=user_prompt,
                system_prompt=system_prompt,
                max_output_tokens=max_output_tokens,
                temperature=temperature,
                expect_json=True,
            )
        else:
            # Fallback на Chat Completions API (устаревший, не рекомендуется)
            result = await self._call_chat_completions(
                user_prompt,
                system_prompt=system_prompt,
                expect_json=True,
                max_tokens=max_output_tokens,
                temperature=temperature,
            )
            
            # Новая сигнатура: возвращает кортеж (text, tokens_usage)
            if isinstance(result, tuple):
                text, tokens_usage = result
            else:
                text = result
                tokens_usage = TokensUsage()
        
        if not text:
            raise ValueError("OpenAI вернул пустой ответ.")
        
        return text, tokens_usage

    async def _call_chat_completions(
        self,
        prompt: str,
        system_prompt: str | None = None,
        expect_json: bool = True,
        max_tokens: int | None = None,
        temperature: float | None = None,
        model_override: str | None = None,
    ) -> str | tuple[str, TokensUsage]:
        """
        Вызов Chat Completions API (gpt-4o, gpt-4o-mini, gpt-4.1-mini, gpt-5-mini и т.п.).
        
        Для моделей семейства gpt-5:
        - Используется max_completion_tokens вместо max_tokens
        - Параметр temperature не поддерживается
        
        Returns:
            str: Текст ответа (старая сигнатура)
            tuple[str, TokensUsage]: Текст ответа и статистика токенов (новая сигнатура)
        """
        messages = [
            {"role": "system", "content": system_prompt or self.SYSTEM_PROMPT},
            {"role": "user", "content": prompt},
        ]
        model_name = model_override or self.model
        is_gpt5_model = self._is_gpt5_model(model_name)  # Проверяем, является ли модель gpt-5
        
        kwargs = {
            "model": model_name,
            "messages": messages,
        }
        if expect_json:
            kwargs["response_format"] = {"type": "json_object"}
        
        # Для моделей gpt-5 не поддерживается temperature
        if not is_gpt5_model:
            temp_value = temperature if temperature is not None else (0.1 if self.supports_temperature else None)
            if temp_value is not None and self.supports_temperature:
                kwargs["temperature"] = temp_value
        
        # Для моделей gpt-5 используется max_completion_tokens вместо max_tokens
        max_value = max_tokens if max_tokens is not None else (2000 if self.supports_max_tokens else None)
        if max_value is not None:
            if is_gpt5_model:
                kwargs["max_completion_tokens"] = max_value
            elif self.supports_max_tokens:
                kwargs["max_tokens"] = max_value

        response = await self.client.chat.completions.create(**kwargs)
        choice0 = response.choices[0]
        msg0 = choice0.message

        # Новые поля SDK: при отказе/фильтре content может быть None, но присутствует reason/refusal.
        refusal = getattr(msg0, "refusal", None)
        if refusal:
            raise ValueError(f"OpenAI отказался отвечать: {refusal}")

        # Иногда может прийти tool_calls вместо content (не ожидаем в этом проекте).
        tool_calls = getattr(msg0, "tool_calls", None)
        if tool_calls and not getattr(msg0, "content", None):
            try:
                dump = json.dumps(msg0.model_dump(), ensure_ascii=False)[:1200]
            except Exception:
                dump = repr(tool_calls)[:800]
            raise ValueError(f"OpenAI вернул tool_calls вместо текста. Fragment: {dump}")

        text = msg0.content or ""
        
        # Извлекаем статистику токенов из response.usage
        # Согласно документации OpenAI, response.usage содержит:
        # - prompt_tokens: количество токенов во входном промпте
        # - completion_tokens: количество токенов в ответе
        # - total_tokens: общее количество токенов
        tokens_usage = TokensUsage()
        if hasattr(response, "usage") and response.usage is not None:
            usage = response.usage
            # Прямой доступ к атрибутам согласно документации OpenAI
            try:
                prompt_tokens = usage.prompt_tokens if hasattr(usage, "prompt_tokens") else 0
                completion_tokens = usage.completion_tokens if hasattr(usage, "completion_tokens") else 0
                # total_tokens может быть не указан, тогда вычисляем его
                if hasattr(usage, "total_tokens") and usage.total_tokens is not None:
                    total_tokens = usage.total_tokens
                else:
                    total_tokens = prompt_tokens + completion_tokens
                
                # Получаем цены токенов (за 1M токенов)
                prompt_price, completion_price = get_effective_pricing(
                    model_name=model_name,
                    prompt_price_override=getattr(settings, "OPENAI_PROMPT_PRICE_PER_1M", 0.0),
                    completion_price_override=getattr(settings, "OPENAI_COMPLETION_PRICE_PER_1M", 0.0),
                )
                
                # Если цены доступны, вычисляем стоимость
                if prompt_price > 0 or completion_price > 0:
                    tokens_usage = calculate_cost(
                        prompt_tokens=prompt_tokens,
                        completion_tokens=completion_tokens,
                        prompt_price_per_1m=prompt_price if prompt_price > 0 else 0.0,
                        completion_price_per_1m=completion_price if completion_price > 0 else 0.0,
                    )
                else:
                    # Сохраняем только количество токенов без стоимости
                    tokens_usage = TokensUsage(
                        prompt_tokens=prompt_tokens,
                        completion_tokens=completion_tokens,
                        total_tokens=total_tokens,
                    )
            except (AttributeError, TypeError) as e:
                # Если возникла ошибка при доступе к атрибутам, логируем и продолжаем
                if settings.DEBUG_MODE:
                    print(f"[OpenAI] Ошибка при извлечении статистики токенов: {e}")
        
        # Если по какой-то причине текст пустой, дадим более полезную диагностику,
        # чтобы понимать первопричину (модель/финиш-статус/формат ответа).
        if not text:
            finish_reason = getattr(choice0, "finish_reason", None)
            try:
                resp_dump = json.dumps(response.model_dump(), ensure_ascii=False)[:1500]
            except Exception:
                resp_dump = repr(response)[:1500]
            raise ValueError(
                "OpenAI вернул пустой ответ. "
                f"finish_reason={finish_reason}. Raw fragment:\n{resp_dump}"
            )

        return text, tokens_usage

    async def _call_responses_api(
        self,
        prompt: str,
        system_prompt: str | None = None,
        max_output_tokens: int | None = None,
        temperature: float | None = None,
        expect_json: bool = True,
    ) -> tuple[str, TokensUsage]:
        """
        Вызов Responses API для всех моделей OpenAI (gpt-4 и gpt-5).
        Согласно документации OpenAI, Responses API - унифицированный интерфейс для всех моделей.
        
        Args:
            prompt: Пользовательский промпт
            system_prompt: Системный промпт (инструкции)
            max_output_tokens: Максимальное количество выходных токенов
            temperature: Температура выборки (0-2, поддерживается только для gpt-4 моделей, для gpt-5 игнорируется)
            expect_json: Ожидать JSON-ответ (использует text.format.type: "json_object")
        
        Returns:
            tuple[str, TokensUsage]: Текст ответа и статистика токенов
        """
        max_tokens = max_output_tokens or self.RESPONSES_JSON_TOKENS
        max_cap = 6000
        last_dump = ""
        
        # Формируем input для Responses API
        # Согласно документации, можно использовать instructions для system prompt
        # и input для user prompt (может быть строкой или массивом input items)
        instructions_text = system_prompt or self.SYSTEM_PROMPT
        input_text = prompt  # Может быть строкой или массивом input items
        
        # Параметры запроса
        kwargs: dict = {
            "model": self.model,
            "instructions": instructions_text,  # System prompt через instructions
            "input": input_text,  # User prompt через input (строка)
        }
        
        # max_output_tokens поддерживается для всех моделей
        if max_tokens:
            kwargs["max_output_tokens"] = max_tokens
        
        # reasoning только для gpt-5 моделей
        is_gpt5 = self._is_gpt5_model(self.model)
        if is_gpt5:
            kwargs["reasoning"] = {"effort": self.reasoning_effort}
            # Для gpt-5 моделей temperature НЕ поддерживается
        else:
            # temperature поддерживается только для gpt-4 моделей
            if temperature is not None:
                kwargs["temperature"] = temperature
            else:
                # По умолчанию используем низкую температуру для детерминированных ответов
                kwargs["temperature"] = 0.1
        
        # JSON формат ответа (text.format.type: "json_object")
        if expect_json:
            kwargs["text"] = {"format": {"type": "json_object"}}

        # Детальный лог запроса в DEBUG (без ключей, с усечёнными промптами)
        if settings.DEBUG_MODE:
            try:
                preview_instructions = (instructions_text or "")[:1200]
                preview_input = (input_text or "")[:1200]
                logger.debug(
                    "[OpenAI][request] model=%s | reasoning=%s | max_out=%s | temperature=%s\n--- instructions ---\n%s\n--- input ---\n%s\n",
                    self.model,
                    (kwargs.get("reasoning", {}).get("effort") if is_gpt5 else "-"),
                    kwargs.get("max_output_tokens"),
                    kwargs.get("temperature"),
                    preview_instructions,
                    preview_input,
                )
                _write_boot_debug(
                    "OpenAI request (responses)",
                    f"model={self.model}\nreasoning={kwargs.get('reasoning')}\nmax_out={kwargs.get('max_output_tokens')}\n"
                    f"temperature={kwargs.get('temperature')}\n\n--- instructions ---\n{instructions_text}\n\n--- input ---\n{input_text}\n",
                )
            except Exception:
                pass

        # Логируем ключевые параметры вызова LLM (без промптов и данных)
        try:
            logger.info(
                "OpenAI call: model=%s, api=responses, prompt_variant=%s, reasoning=%s, temperature=%s, max_output_tokens=%s",
                self.model,
                (getattr(settings, "OPENAI_PROMPT_VARIANT", "compact_v2") or "compact_v2"),
                (kwargs.get("reasoning", {}).get("effort") if is_gpt5 else "-"),
                kwargs.get("temperature"),
                kwargs.get("max_output_tokens"),
            )
        except Exception:
            pass

        for attempt in range(3):
            try:
                response = await self.client.responses.create(**kwargs)
                
                # Извлекаем текст из ответа
                text = self._extract_text_from_response(response)
                if text:
                    if settings.DEBUG_MODE:
                        try:
                            logger.debug(
                                "[OpenAI][response] model=%s | len=%s | preview:\n%s",
                                self.model,
                                len(text),
                                text[:1200],
                            )
                            _write_boot_debug(
                                "OpenAI response (responses)",
                                f"model={self.model}\nlen={len(text)}\n\n--- full text ---\n{text}\n",
                            )
                        except Exception:
                            pass
                    # Извлекаем статистику токенов из response.usage
                    tokens_usage = self._extract_tokens_usage_from_response(response)
                    return text, tokens_usage

                # Если текст пустой, проверяем причину
                try:
                    last_dump = json.dumps(response.model_dump(), ensure_ascii=False, indent=2)[:1500]
                except Exception:
                    last_dump = repr(response)

                details = getattr(response, "incomplete_details", None) or {}
                reason = getattr(details, "reason", None) or details.get("reason")

                # Автоувеличение лимита токенов при необходимости
                if reason == "max_output_tokens" and max_tokens < max_cap:
                    max_tokens = min(max_cap, int(max_tokens * 1.8))
                    kwargs["max_output_tokens"] = max_tokens
                    await asyncio.sleep(0.2)
                    continue

                if attempt < 2:
                    await asyncio.sleep(0.2)
            except Exception:
                if attempt < 2:
                    await asyncio.sleep(0.2)
                    continue
                raise

        raise ValueError(
            "OpenAI вернул пустой ответ для Responses API. Raw fragment:\n"
            f"{last_dump}"
        )
    
    def _extract_tokens_usage_from_response(self, response) -> TokensUsage:
        """
        Извлекает статистику токенов из ответа Responses API.
        
        Согласно документации, usage содержит:
        - input_tokens: количество входных токенов
        - output_tokens: количество выходных токенов
        - output_tokens_details.reasoning_tokens: токены рассуждений (для gpt-5)
        - total_tokens: общее количество токенов
        """
        tokens_usage = TokensUsage()
        
        try:
            usage = getattr(response, "usage", None)
            if not usage:
                return tokens_usage
            
            # Извлекаем токены
            input_tokens = getattr(usage, "input_tokens", 0) or 0
            output_tokens = getattr(usage, "output_tokens", 0) or 0
            total_tokens = getattr(usage, "total_tokens", 0) or 0
            
            # Если total_tokens не указан, вычисляем
            if not total_tokens:
                total_tokens = input_tokens + output_tokens
            
            # Получаем цены токенов (автоматически из openai_pricing.py, если не указаны в .env)
            prompt_price, completion_price = get_effective_pricing(
                model_name=self.model,
                prompt_price_override=getattr(settings, "OPENAI_PROMPT_PRICE_PER_1M", 0.0),
                completion_price_override=getattr(settings, "OPENAI_COMPLETION_PRICE_PER_1M", 0.0),
            )
            
            # Вычисляем стоимость
            if prompt_price > 0 or completion_price > 0:
                tokens_usage = calculate_cost(
                    prompt_tokens=input_tokens,
                    completion_tokens=output_tokens,
                    prompt_price_per_1m=prompt_price if prompt_price > 0 else 0.0,
                    completion_price_per_1m=completion_price if completion_price > 0 else 0.0,
                )
            else:
                # Сохраняем только количество токенов без стоимости
                tokens_usage = TokensUsage(
                    prompt_tokens=input_tokens,
                    completion_tokens=output_tokens,
                    total_tokens=total_tokens,
                )
        except (AttributeError, TypeError) as exc:
            if settings.DEBUG_MODE:
                logger.warning(f"[OpenAI] Ошибка при извлечении статистики токенов: {exc}")
        
        return tokens_usage

    async def translate_text(
        self, text: str, target_language: str = "ru"
    ) -> str | tuple[str, TokensUsage]:
        """
        Переводит текст на указанный язык через выбранную модель OpenAI.
        
        Returns:
            str: Переведённый текст (старая сигнатура)
            tuple[str, TokensUsage]: Переведённый текст и статистика токенов (новая сигнатура)
        """
        if not text:
            return text, TokensUsage()

        user_prompt = (
            f"Переведи следующий текст на {target_language}. "
            "Ответь только переводом без пояснений.\n\n"
            f"{text}"
        )

        # Используем Responses API для переводов (если включено)
        if self.use_responses_api:
            translated, tokens_usage = await self._call_responses_api(
                prompt=user_prompt,
                system_prompt="Ты профессиональный переводчик.",
                max_output_tokens=self.RESPONSES_TRANSLATE_TOKENS,
                temperature=0.1,
                expect_json=False,
            )
        else:
            # Fallback на Chat Completions API (устаревший)
            result = await self._call_chat_completions(
                user_prompt,
                system_prompt="Ты профессиональный переводчик.",
                expect_json=False,
                max_tokens=self.RESPONSES_TRANSLATE_TOKENS,
                temperature=0.1,
            )
            # Новая сигнатура: возвращает кортеж (text, tokens_usage)
            if isinstance(result, tuple):
                translated, tokens_usage = result
            else:
                translated = result
                tokens_usage = TokensUsage()
        return (translated.strip() or text), tokens_usage

    @staticmethod
    def _extract_text_from_response(response) -> str:
        """
        Собирает текст из Responses API (response.output[*].content[*].text)
        """
        chunks: list[str] = []
        output = getattr(response, "output", None) or []
        for item in output:
            content_list: Iterable = getattr(item, "content", None) or []
            for part in content_list:
                text_value = OpenAIClient._extract_text_from_part(part)
                if text_value:
                    chunks.append(text_value)
        if chunks:
            return "".join(chunks)

        # fallback: некоторые версии SDK предоставляют output_text
        output_text = getattr(response, "output_text", None)
        if output_text:
            return output_text
        return ""

    @staticmethod
    def _extract_text_from_part(part) -> str:
        """
        Универсально вынимает текст из элемента ответа Responses API.
        """
        # dataclass с атрибутом text
        text_attr = getattr(part, "text", None)
        if text_attr:
            if isinstance(text_attr, str):
                return text_attr
            if isinstance(text_attr, list):
                pieces = []
                for segment in text_attr:
                    segment_text = getattr(segment, "text", None)
                    if segment_text:
                        pieces.append(segment_text)
                    elif isinstance(segment, dict):
                        value = segment.get("text")
                        if value:
                            pieces.append(value)
                if pieces:
                    return "".join(pieces)

        # Словарь
        if isinstance(part, dict):
            value = part.get("text")
            if isinstance(value, str):
                return value
            if isinstance(value, list):
                pieces = [seg.get("text") for seg in value if isinstance(seg, dict) and seg.get("text")]
                return "".join(pieces)

        return ""

    @staticmethod
    def _build_responses_input(system_text: str, user_text: str) -> list[dict]:
        """
        Формирует input items для Responses API (альтернативный способ, если не используется instructions).
        Согласно документации, input может быть строкой или массивом input items.
        """
        return [
            {
                "role": "system",
                "content": [{"type": "input_text", "text": system_text}],
            },
            {
                "role": "user",
                "content": [{"type": "input_text", "text": user_text}],
            },
        ]

